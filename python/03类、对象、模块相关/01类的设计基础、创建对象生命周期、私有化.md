# 类的设计基础、创建对象生命周期、私有化

在使用面相对象开发前，应该首先分析需求，确定一下，程序中需要包含哪些类！

在程序开发中，要设计一个类，通常需要满足一下三个要素：

1. 类名 这类事物的名字，满足大驼峰命名法

2. 属性 这类事物具有什么样的特征

3. 方法 这类事物具有什么样的行为

## 一、基础知识

#### 1.大驼峰命名法

CapWords

1. 每一个单词的首字母大写

2. 单词与单词之间没有下划线

#### 2.类名的确定

名词提炼法 分析 整个业务流程，出现的 名词，通常就是找到的类

#### 3.属性和方法的确定

- 对 对象的特征描述，通常可以定义成 属性

- 对象具有的行为（动词），通常可以定义成 方法

> 提示：需求中没有涉及的属性或者方法在设计类时，不需要考虑

#### 4.dir 内置函数（知道）

- 在 Python 中 对象几乎是无所不在的，我们之前学习的 变量、数据、函数 都是对象

在 Python 中可以使用以下两个方法验证：

1. 在 标识符 / 数据 后输入一个 .，然后按下 TAB 键，iPython 会提示该对象能够调用的 方法列表

2. 使用内置函数 dir 传入 标识符 / 数据，可以查看对象内的 所有属性及方法

提示 __方法名__ 格式的方法是 Python 提供的 内置方法 / 属性，稍后会给大家介绍一些常用的 内置方法 / 属性

|     |          |     |                        |
| --- | -------- | --- | ---------------------- |
| 序号  | 方法名      | 类型  | 作用                     |
| 01  | __new__  | 方法  | 创建对象时，会被 自动 调用         |
| 02  | __init__ | 方法  | 对象被初始化时，会被 自动 调用       |
| 03  | __del__  | 方法  | 对象被从内存中销毁前，会被 自动 调用    |
| 04  | __str__  | 方法  | 返回对象的描述信息，print 函数输出使用 |

提示 利用好 dir() 函数，在学习时很多内容就不需要死记硬背了

## 二、创建对象

- 当一个类定义完成之后，要使用这个类来创建对象，语法格式如下：

```py
对象变量 = 类名()
```

#### 1.引用概念的强调

> 在面向对象开发中，引用的概念是同样适用的！

- %d 可以以 10 进制 输出数字

- %x 可以以 16 进制 输出数字    print("%x" % id(对象))

**类创建好之后，可以再添加类的属性，但这样子不太好**

```py
class Cat:
    def eat(self): 
        print("%s 爱吃鱼" % self.name)
tom = Cat()
tom.name = "Tom" 
tom.eat()

def __init__(self):
    print("初始化方法")

def __del__(self):
    print("类结束了")
```

#### 2.生命周期

> - 一个对象从调用 类名() 创建，生命周期开始
> 
> - 一个对象的 **del** 方法一旦被调用，生命周期结束
> 
> - 在对象的生命周期内，可以访问对象属性，或者让对象调用方法

```py
def __str__(self):

    return "我是小猫：%s" % self.name
```

> - 在 Python 中，使用 print 输出 对象变量，默认情况下，会输出这个变量 引用的对象 是 由哪一个类创建的对象，以及 在内存中的地址（十六进制表示）
> 
> - 如果在开发中，希望使用 print 输出 对象变量 时，能够打印 自定义的内容，就可以利用 **str** 这个内置方法了

注意：__str__ 方法必须返回一个字符串

## 三、私有化

> - xx: 公有变量
> - _x: 单前置下划线,私有化属性或方法，from somemodule import *禁止导入,类对象和子类可以访问
> - __xx：双前置下划线,避免与子类中的属性命名冲突，无法在外部直接访问(名字重整所以访问不到)
> - **xx**:双前后下划线,用户名字空间的魔法对象或属性。例如:`__init__` , __ 不要自己发明这样的名字
> - xx_:单后置下划线,用于避免与Python关键词的冲突

通过name mangling（名字重整(目的就是以防子类意外重写基类的方法或者属性)如：_Class__object）机制就可以访问private了。

> - 父类中属性名为`__名字`的，子类不继承，子类不能访问
> - 如果在子类中向`__名字`赋值，那么会在子类中定义的一个与父类相同名字的属性
> - `_名`的变量、函数、类在使用`from xxx import *`时都不会被导入

#### 1.私有属性和私有方法

> 应用场景
> 
> - 在实际开发中，对象 的 某些属性或方法 可能只希望 在对象的内部被使用，而 不希望在外部被访问到
> 
> - 私有属性 就是 对象 不希望公开的 属性
> 
> - 私有方法 就是 对象 不希望公开的 方法

定义方式

- 在 定义属性或方法时，在 属性名或者方法名前 增加 两个下划线，定义的就是 私有 属性或方法

```py
class Women:
    def __init__(self, name): 
        self.name = name
        # 不要问女生的年龄 
        self.__age = 18 
    def __secret(self): 
        print("我的年龄是 %d" % self.__age)
xiaofang = Women("小芳") 
# 私有属性，外部不能直接访问 
# print(xiaofang.__age)
# 私有方法，外部不能直接调用 
# xiaofang.__secret()
```

#### 2.伪私有属性和私有方法（科普）

> 提示：在日常开发中，不要使用这种方式，访问对象的 私有属性 或 私有方法

Python 中，并没有 真正意义 的 私有

- 在给 属性、方法 命名时，实际是对 名称 做了一些特殊处理，使得外界无法访问到

- 处理方式：在 名称 前面加上 _类名 => _类名__名称

```py
# 私有属性，外部不能直接访问到
print(xiaofang._Women__age)

# 私有方法，外部不能直接调用   像这样子就可以访问了
xiaofang._Women__secret()
```

#### 3.私有化本质

> - 创建的类.__dict__可以查看类里面的属性
> 
> - 可以看到，属性私有化实际上就是把变量名 改为 _类名___属性名

```py
>>> class Test(object):
	def __init__(self,name):
		self.__name = name

		
>>> a = Test('nb')
>>> a.__name    #报错
Traceback (most recent call last):
  File "<pyshell#6>", line 1, in <module>
    a.__name
AttributeError: 'Test' object has no attribute '__name' 
>>> a.__dict__
{'_Test__name': 'nb'}
>>> a._Test__name
'nb'
>>> a.__name = 'wc' #名字重整   实际上是创建了新属性
>>> a.__dict__
{'_Test__name': 'nb', '__name': 'wc'}
>>> a.__name
'wc'
>>> 
```

这个方法可以用来查看、修改私有属性     和名字重整



end
