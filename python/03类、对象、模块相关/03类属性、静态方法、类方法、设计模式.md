# 类属性、静态方法、类方法、设计模式

----

# 一、类是一个特殊的对象

> Python 中 一切皆对象：
> 
> - class AAA: 定义的类属于 类对象
> 
> - obj1 = AAA() 属于 实例对象

> - 在程序运行时，类 同样 会被加载到内存
> 
> - 在 Python 中，类 是一个特殊的对象 —— 类对象
> 
> - 在程序运行时，类对象 在内存中 只有一份，使用 一个类 可以创建出 很多个对象实例
> 
> - 除了封装 实例 的 属性 和 方法外，类对象 还可以拥有自己的 属性 和 方法
> 1. 类属性
> 
> 2. 类方法
> - 通过 类名. 的方式可以 访问类的属性 或者 调用类的方法

----

# 二、类属性和实例属性

#### 1.概念和使用

> - 类属性 就是给 类对象 中定义的 属性
> 
> - 通常用来记录 与这个类相关 的特征
> 
> - 类属性 不会用于记录 具体对象的特征

```py
class Tool(object):

# 使用赋值语句，定义类属性，记录创建工具对象的总数
count = 0

def __init__(self, name):
self.name = name

# 针对类属性做一个计数+1
Tool.count += 1


# 创建工具对象
tool1 = Tool("斧头")
tool2 = Tool("榔头")
tool3 = Tool("铁锹")

# 知道使用 Tool 类到底创建了多少个对象?
print("现在创建了 %d 个工具" % Tool.count)
```

#### 2.属性的获取机制（科普）

![mg](img/019_通过对象访问类属性.png)

因此，要访问类属性有两种方式：

> 1. 类名.类属性
> 
> 2. 对象.类属性 （不推荐）

> 注意
> 
> - 如果使用 对象.类属性 = 值 赋值语句，只会 给对象添加一个属性，而不会影响到 类属性的值

----

# 三、类方法和静态方法

#### 1.类方法

> - 类属性 就是针对 类对象 定义的属性
> 
> - 使用 赋值语句 在 class 关键字下方可以定义 类属性
> 
> - 类属性 用于记录 与这个类相关 的特征
> 
> - 类方法 就是针对 类对象 定义的方法
> 
> - 在 类方法 内部可以直接访问 类属性 或者调用其他的 类方法

语法如下

```py
@classmethoddef 类方法名(cls):
    pass
```

> - 类方法需要用 修饰器 @classmethod 来标识，告诉解释器这是一个类方法
> 
> - 类方法的 第一个参数 应该是 cls 
>   
>   - 由 哪一个类 调用的方法，方法内的 cls 就是 哪一个类的引用
>   
>   - 这个参数和 实例方法 的第一个参数是 self 类似
>   
>   - 提示 使用其他名称也可以，不过习惯使用 cls
> 
> - 通过 类名. 调用 类方法，调用方法时，不需要传递 cls 参数
> 
> - 在方法内部
>   
>   - 可以通过 cls. 访问类的属性
>   
>   - 也可以通过 cls. 调用其他的类方法

```py
@classmethoddef show_tool_count(cls):
    """显示工具对象的总数"""
    print("工具对象的总数 %d" % cls.count)
```

在类方法内部，可以直接使用 cls 访问 类属性 或者 调用类方法

#### 2.静态方法

> - 在开发时，如果需要在 类 中封装一个方法，这个方法：
> 
> - 既 不需要 访问 实例属性 或者调用 实例方法
> 
> - 也 不需要 访问 类属性 或者调用 类方法
> 
> - 这个时候，可以把这个方法封装成一个 静态方法

语法如下

```py
@staticmethoddef 静态方法名():
pass
```

> - 静态方法 需要用 修饰器 @staticmethod 来标识，告诉解释器这是一个静态方法
> 
> - 通过 类名. 调用 静态方法

总结

> 1. 实例方法 —— 方法内部需要访问 实例属性
>    
>    - 实例方法 内部可以使用 类名. 访问类属性
> 
> 2. 类方法 —— 方法内部 只 需要访问 类属性
> 
> 3. 静态方法 —— 方法内部，不需要访问 实例属性 和 类属性

提问

> 如果方法内部 即需要访问 实例属性，又需要访问 类属性，应该定义成什么方法？
> 
> 答案
> 
> - 应该定义 实例方法
> 
> - 因为，类只有一个，在 实例方法 内部可以使用 类名. 访问类属性

----

## 四、单例设计模式

> - 设计模式
>   
>   - 设计模式 是 前人工作的总结和提炼，通常，被人们广泛流传的设计模式都是针对 某一特定问题 的成熟的解决方案
>   
>   - 使用 设计模式 是为了可重用代码、让代码更容易被他人理解、保证代码可靠性
> 
> - 单例设计模式
>   
>   - 目的 —— 让 类 创建的对象，在系统中 只有 唯一的一个实例
>   
>   - 每一次执行 类名() 返回的对象，内存地址是相同的

#### 1.__new__ 方法

> - 使用 类名() 创建对象时，Python 的解释器 首先 会 调用 **new** 方法为对象 分配空间
> 
> - **new** 是一个 由 object 基类提供的 内置的静态方法，主要作用有两个：
>     - 1)在内存中为对象 分配空间
>   
>     - 2)返回 对象的引用
>   
> - Python 的解释器获得对象的 引用 后，将引用作为 第一个参数，传递给 **init** 方法
> 
> > 重写 **new** 方法 的代码非常固定！
> 
> - 重写 **new** 方法 一定要 return super().**new**(cls)
> 
> - 否则 Python 的解释器 得不到 分配了空间的 对象引用，就不会调用对象的初始化方法
> 
> - 注意：**new** 是一个静态方法，在调用时需要 主动传递 cls 参数

#### 2.Python 中的单例

> - 单例 —— 让 类 创建的对象，在系统中 只有 唯一的一个实例
> 1. 定义一个 类属性，初始值是 None，用于记录 单例对象的引用
> 
> 2. 重写 **new** 方法
> 
> 3. 如果 类属性 is None，调用父类方法分配空间，并在类属性中记录结果
> 
> 4. 返回 类属性 中记录的 对象引用

```py
class MusicPlayer(object):

	# 定义类属性记录单例对象引用
	instance = None

	def __new__(cls, *args, **kwargs):

		# 1. 判断类属性是否已经被赋值
		if cls.instance is None:
			cls.instance = super().__new__(cls)

		# 2. 返回类属性的单例引用
		return cls.instance
```

#### 3.只执行一次初始化工作

> - 在每次使用 类名() 创建对象时，Python 的解释器都会自动调用两个方法：
>   
>   - **new** 分配空间
>   
>   - **init** 对象初始化
> 
> - 在上一小节对 **new** 方法改造之后，每次都会得到 第一次被创建对象的引用
> 
> - 但是：初始化方法还会被再次调用

需求

- 让 初始化动作 只被 执行一次

解决办法

> 1. 定义一个类属性 init_flag 标记是否 执行过初始化动作，初始值为 False
> 
> 2. 在 **init** 方法中，判断 init_flag，如果为 False 就执行初始化动作
> 
> 3. 然后将 init_flag 设置为 True
> 
> 4. 这样，再次 自动 调用 **init** 方法时，初始化动作就不会被再次执行 了